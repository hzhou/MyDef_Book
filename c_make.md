Makefile
--------

C need to be compiled before it can be tested. One of the key idea of MyDef is not to attempt to get it right the first time, but rely on feedbacks from low level compiler and tests to balance the benefits of semantic efficiency and low level accuracy. An short feedback loop is essestial for this strategy to work. We need automate the compiling cycles and to do this, we use Makefile.

Let's start in a empty project folder. Create a def file, let's say t.def:

```
page: t, basic_frame
    $print Hello world!

```

Run mydef_make:
```
$ mydef_make
Please enter the path to compile into [out]:

Please enter module type [perl]:
c
    output_dir: out
Create output folder out ...
$ make
mydef_page t.def out/t.c
PAGE: t
  ---> out/Makefile
  --> [out/t.c]

```
(mydef_make offers "perl" as a default output module, here we overwrite it to c.)

We notice that upon "make", MyDef not only creates the C code, out/t.c, but also created a Makefile in the "out" folder. "mydef_page" will generate a default Makefile if the C output contains a "main" C function and the output folder does not already contain an exisiting Makefile.

Now if we run mydef_make again and then try to run "make all":

```
$ mydef_make
     output_dir: out
$
$ touch t.def
$
$ make all
mydef_page t.def out/t.c
PAGE: t
  --> [out/t.c]
make -C out
make[1]: Entering directory `out'
gcc -c   -o t.o t.c
gcc   -o t t.o
make[1]: Leaving directory `out'
$
$ out/t
Hello world!
```

So we can edit def source, and run "make all" to have all compilation updated and ready to test. 

When we run mydef_make, mydef_make will examine all def file, and if the def file produces a page(file), it will create an entry in the Makefile. Then it will examin of existing folders and see if any folder contains def files or Makefile. If the subfolder contains def file, mydef_make will check and if necessary, create additional Makefile in the subfolder. If the subfolder contains Makefile, mydef_make will include that subfolder into its main Makefile. All the subfolder targets are included in the "all" target, so "make all" updates all of them. On the other hand, if one simply runs "make", only the main folder targets are updated.

Let's look at the sub Makefile mydef_page generated by default:
```
CC=gcc

t: t.o 
	$(CC) $(LIB)  -o t $^

%.o: %.c
	$(CC) -c $(CFLAGS) $(INC) -o $@ $<
```

It is a very basic one. For large projects, one may manually edit the Makefile or simply use the Makefile generated by project manager. MyDef will simply include it in its "all" target.

